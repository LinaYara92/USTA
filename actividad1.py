# -*- coding: utf-8 -*-
"""Actividad1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18p9mlqJ6DZ2DujBFcuQWX628Wn3UxHPi
"""

# Este Código a través de la librería Sympy, permite comprobar fórmulas aritméticas a través de la Inducción matemática

# Se importa la librería Sympy y se declaran variables utilizando caracteres Unicode
from sympy import *
x, y, z, k, n = symbols('x y z k n')
init_printing(use_unicode=True)

# Convierte la formula a simbólica y comprueba si el resulta es igual a base_case

def verify_base_case(formula, valid_from_n, base_case):
    computed_base_case = (sympify(formula)).subs(n, valid_from_n)
    base_case_satisfied = computed_base_case == base_case
    return base_case_satisfied

# Expande la hipótesis para el término k +1 y simplifica el resultado

def expand_induction_hypothesis_k_plus_1(formula, next_expression):
    # inductive hypothesis
    inductive_step = formula.replace('n', 'k') + '+' + next_expression.replace('n', 'k')
    return expand(inductive_step)
# Expande la fórmula para el término k+1

def expand_formula_k_plus_1(formula):
    return expand(formula.replace('n', '(k+1)'))
#Comprueba si la formula se cumple mediante la inducción matemática

def prove_arithmetic_series_formula(formula, valid_from_n, base_case, next_expression):
    # verify base case
    base_case_satisfied = verify_base_case(formula, valid_from_n, base_case)

    # Inductive step
    inductive_hypothesis = expand_induction_hypothesis_k_plus_1(formula, next_expression)
    formula_next_term = expand_formula_k_plus_1(formula)

    # If the inductive hypothesis matches the formula for the next term
    # then we have proved the formula
    return {
        'base_case_satisfied': base_case_satisfied,
        'inductive_hypothesis': inductive_hypothesis,
        'formula_next_term': formula_next_term,
        'proved': base_case_satisfied and inductive_hypothesis == formula_next_term
    }
# Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso la suma de los números pares
# Sum of all even numbers
INPUT_FORMULA = 'n*(n+1)'
INPUT_VALID_FROM_N = 1
INPUT_BASE_CASE = 2
INPUT_NEXT_STEP = '2*(n+1)'

#Impresión de los resultados de la comprobación
print(prove_arithmetic_series_formula(INPUT_FORMULA,INPUT_VALID_FROM_N,INPUT_BASE_CASE, INPUT_NEXT_STEP))

# Este Código a través de la librería Sympy, permite comprobar fórmulas aritméticas a través de la Inducción matemática

# Se importa la librería Sympy y se declaran variables utilizando caracteres Unicode
from sympy import *
x, y, z, k, n = symbols('x y z k n')
init_printing(use_unicode=True)

# Convierte la formula a simbólica y comprueba si el resulta es igual a base_case

def verify_base_case(formula, valid_from_n, base_case):
    computed_base_case = (sympify(formula)).subs(n, valid_from_n)
    base_case_satisfied = computed_base_case == base_case
    return base_case_satisfied

# Expande la hipótesis para el término k +1 y simplifica el resultado

def expand_induction_hypothesis_k_plus_1(formula, next_expression):
    # inductive hypothesis
    inductive_step = formula.replace('n', 'k') + '+' + next_expression.replace('n', 'k')
    return expand(inductive_step)
# Expande la fórmula para el término k+1

def expand_formula_k_plus_1(formula):
    return expand(formula.replace('n', '(k+1)'))
#Comprueba si la formula se cumple mediante la inducción matemática

def prove_arithmetic_series_formula(formula, valid_from_n, base_case, next_expression):
    # verify base case
    base_case_satisfied = verify_base_case(formula, valid_from_n, base_case)

    # Inductive step
    inductive_hypothesis = expand_induction_hypothesis_k_plus_1(formula, next_expression)
    formula_next_term = expand_formula_k_plus_1(formula)

    # If the inductive hypothesis matches the formula for the next term
    # then we have proved the formula
    return {
        'base_case_satisfied': base_case_satisfied,
        'inductive_hypothesis': inductive_hypothesis,
        'formula_next_term': formula_next_term,
        'proved': base_case_satisfied and inductive_hypothesis == formula_next_term
    }
# Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso Suma de los primeros números impares
# Suma de los primeros números impares
INPUT_FORMULA = 'n**2'
INPUT_VALID_FROM_N = 1
INPUT_BASE_CASE = 1  # 1^2 = 1
INPUT_NEXT_STEP = '2*n + 1'  # Siguiente número impar

#Impresión de los resultados de la comprobación
print(prove_arithmetic_series_formula(INPUT_FORMULA,INPUT_VALID_FROM_N,INPUT_BASE_CASE, INPUT_NEXT_STEP))

#Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso suma de los n cubos
# Suma de los n cubos
INPUT_FORMULA = '(n*(n+1)//2)**2'
INPUT_VALID_FROM_N = 1
INPUT_BASE_CASE = 1  # 1^3 = 1
INPUT_NEXT_STEP = '(n+1)**3'
print(prove_arithmetic_series_formula(INPUT_FORMULA,INPUT_VALID_FROM_N,INPUT_BASE_CASE, INPUT_NEXT_STEP))

#Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso suma de los primeros factoriales
# Suma de los primeros factoriales
INPUT_FORMULA = 'factorial(n+1) - 1'
INPUT_VALID_FROM_N = 1
INPUT_BASE_CASE = 1  # 2! - 1 = 1
INPUT_NEXT_STEP = 'factorial(n+2) - 1'  # próximo término factorial
print(prove_arithmetic_series_formula(INPUT_FORMULA,INPUT_VALID_FROM_N,INPUT_BASE_CASE, INPUT_NEXT_STEP))

#Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso la fórmula del Triángulo de Pascal
# Fórmula del Triángulo de Pascal
INPUT_FORMULA = '2**n'
INPUT_VALID_FROM_N = 0
INPUT_BASE_CASE = 1  # 2^0 = 1
INPUT_NEXT_STEP = '2**(n+1)'  # Próxima potencia de 2
{'base_case_satisfied': True, 'inductive_hypothesis': factorial(k + 1) + factorial(k + 2) - 2, 'formula_next_term': factorial(k + 2) - 1, 'proved': False}

#Ejemplo de fórmula para verificar hipótesis de Inducción, en este caso la fórmula de los números primeros
# Fórmula de los números primeros
INPUT_FORMULA = '2 + Sum(factorial(k) % (k+1), (k, 1, n))'
INPUT_VALID_FROM_N = 1
INPUT_BASE_CASE = 2  # Primer número primo
INPUT_NEXT_STEP = 'factorial(n) % (n+1)'  # Siguiente evaluación
{'base_case_satisfied': True, 'inductive_hypothesis': factorial(k + 1) + factorial(k + 2) - 2, 'formula_next_term': factorial(k + 2) - 1, 'proved': False}

from sympy import symbols, expand, sympify

# Definir variables simbólicas
n, k = symbols('n k')

def verify_base_case(formula, valid_from_n, base_case):
    computed_base_case = sympify(formula).subs(n, valid_from_n)
    return computed_base_case == base_case

def expand_induction_hypothesis_k_plus_1(formula):
    inductive_step = formula.replace('n', 'k') + '*2'
    return expand(sympify(inductive_step))

def expand_formula_k_plus_1(formula):
    return expand(sympify(formula).subs(n, k+1))

def prove_power_set_cardinalidad(formula, valid_from_n, base_case):
    base_case_satisfied = verify_base_case(formula, valid_from_n, base_case)

    inductive_hypothesis = expand_induction_hypothesis_k_plus_1(formula)
    formula_next_term = expand_formula_k_plus_1(formula)

    return {
        'base_case_satisfied': base_case_satisfied,
        'inductive_hypothesis': inductive_hypothesis,
        'formula_next_term': formula_next_term,
        'proved': base_case_satisfied and inductive_hypothesis == formula_next_term
    }

# Definir la fórmula para la cardinalidad del conjunto potencia
INPUT_FORMULA = '2**n'
INPUT_VALID_FROM_N = 0  #  Conjunto de tipo vacío tiene un conjunto potencia de cardinalidad 1 (2^0 = 1)
INPUT_BASE_CASE = 1

print(prove_power_set_cardinalidad(INPUT_FORMULA, INPUT_VALID_FROM_N, INPUT_BASE_CASE))